import 'dart:convert';
import 'dart:math';
import 'package:crypto/crypto.dart';

/// Helper class for implementing Proof Key for Code Exchange (PKCE)
/// 
/// PKCE is mandatory for mobile applications as of 2024 OAuth 2.0 security best practices.
/// This implementation follows RFC 7636 specifications for enhanced security in OAuth flows.
/// 
/// Example usage:
/// ```dart
/// final verifier = PKCEHelper.generateCodeVerifier();
/// final challenge = PKCEHelper.generateCodeChallenge(verifier);
/// // Use challenge in OAuth authorization request
/// // Store verifier for token exchange
/// ```
class PKCEHelper {
  /// Minimum length for code verifier (RFC 7636)
  static const int _minVerifierLength = 43;
  
  /// Maximum length for code verifier (RFC 7636)
  static const int _maxVerifierLength = 128;
  
  /// Default length for generated code verifier
  static const int _defaultVerifierLength = 64;
  
  /// Characters allowed in code verifier (RFC 7636)
  static const String _allowedChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';

  /// Generate a cryptographically secure code verifier
  /// 
  /// Creates a URL-safe string of [length] characters using cryptographically
  /// secure random number generation. The length must be between 43-128 characters
  /// as specified in RFC 7636.
  /// 
  /// [length] The length of the code verifier (default: 64, min: 43, max: 128)
  /// 
  /// Returns a URL-safe code verifier string for PKCE implementation.
  /// 
  /// Throws [ArgumentError] if length is outside the valid range.
  static String generateCodeVerifier({int length = _defaultVerifierLength}) {
    if (length < _minVerifierLength || length > _maxVerifierLength) {
      throw ArgumentError(
        'Code verifier length must be between $_minVerifierLength and $_maxVerifierLength characters',
      );
    }
    
    final random = Random.secure();
    final buffer = StringBuffer();
    
    for (int i = 0; i < length; i++) {
      buffer.write(_allowedChars[random.nextInt(_allowedChars.length)]);
    }
    
    return buffer.toString();
  }

  /// Generate code challenge from code verifier using S256 method
  /// 
  /// Creates a SHA256 hash of the [verifier] and encodes it as base64url
  /// without padding, as required by the S256 code challenge method in RFC 7636.
  /// 
  /// [verifier] The code verifier generated by [generateCodeVerifier]
  /// 
  /// Returns a base64url-encoded SHA256 hash of the verifier (without padding).
  /// 
  /// Throws [ArgumentError] if verifier is null or empty.
  static String generateCodeChallenge(String verifier) {
    if (verifier.isEmpty) {
      throw ArgumentError('Code verifier cannot be empty');
    }
    
    final bytes = utf8.encode(verifier);
    final digest = sha256.convert(bytes);
    return base64UrlEncode(digest.bytes).replaceAll('=', '');
  }

  /// Validate a code verifier meets RFC 7636 requirements
  /// 
  /// Checks that the [verifier] has the correct length and contains only
  /// allowed characters as specified in RFC 7636.
  /// 
  /// [verifier] The code verifier to validate
  /// 
  /// Returns [true] if the verifier is valid, [false] otherwise.
  static bool isValidCodeVerifier(String verifier) {
    if (verifier.length < _minVerifierLength || verifier.length > _maxVerifierLength) {
      return false;
    }
    
    final allowedCharSet = Set<String>.from(_allowedChars.split(''));
    return verifier.split('').every((char) => allowedCharSet.contains(char));
  }

  /// Get the code challenge method identifier
  /// 
  /// Returns 'S256' as this implementation uses SHA256 hashing,
  /// which is the recommended method for PKCE in RFC 7636.
  static String get codeChallengeMethod => 'S256';
}
